## 动态规划
所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

### 01背包
https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%8401%E8%83%8C%E5%8C%85

##### 1.dp数组的含义
通过构造2维dp数组，外层循环物品，内层循环背包容量，
dp[i][j]代表当前可选的物品范围为0-i，容量为j，dp[i][j]为在可选范围内的最大物品价值
##### 2.确定递推公式
dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-weight[i]])
##### 3.dp数组如何初始化
##### 4.确定遍历顺序


#### 背包衍生问题解法：
1.判断是否是背包问题
2.分析背包的体积w是，商品的重量数组weight和价值数组value是多少
3.思考dp数组的含义和dp的递推公式

#### 背包衍生问题(以下都是滚动数组解法的递推公式)：
1.能否装满背包(最多装多少)(原生)
dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
2.装满背包有几种方法
(减去自身重量的对应的上一个dp的方法数（这代表当前的物品被采用）加上上一个不包含当前物品的dp数（这代表当前的物品不被采用）)
dp[j] += dp[j - nums[i]]
3.背包装满的最大价值
4.装满背包所有物品的最小割属

## 题解
####  01背包
1.找变量
体积w，价值数组，重量数组，数组长度(物品数量len)

#### 2.目标和
1.找变量
left组合 - right组合 = target。
left组合 + right组合 = sum
left-（sum-left）=target
left= (target + sum)/2 
也就是加法的总和 x=(target + sum)/2
2.转换问题
问题转化为装满容量为x的背包，有几种方法，注意一些边界
（target + sum）%2===1的话（即target + sum为奇数），无解
3.
